continue
Prospect.find(params[:prospect])
continue
params[:prospect]
params
@prospect
prospect
continue
payments
@payments
bill.total
exit
Ticket.where("DATE_TRUNC('month', created_at)" == 1)
pp Ticket.where("DATE_TRUNC('month', created_at)" == 1000000)
pp Ticket.where("DATE_TRUNC('month', created_at)" == 1)
pp Ticket.where("DATE_TRUNC('month', created_at)")
pp Ticket.where("DATE_TRUNC('month', created_at)" == 200)
pp Ticket.where("DATE_TRUNC('month', created_at)" == 13)
pp Ticket.where("DATE_TRUNC('month', created_at)" == 12)
pp Ticket.where("DATE_TRUNC('month', created_at)" == 11)
pp Ticket.where("DATE_TRUNC('month', created_at)" == 10)
pp Ticket.where("DATE_TRUNC('month', created_at)" == month)
month = 10
month
pp Ticket.where("DATE_TRUNC('month', created_at)" == month)
PP Ticket.where("DATE_TRUNC('month', created_at)" == month)
Ticket.where("DATE_TRUNC('month', created_at)" == month)
Tickets.where("DATE_TRUNC('month', created_at)" == month)
pp stoickets.where(tickets: {created_at: "DATE_TRUNC('month', created_at)" == month})
pp store.tickets.where(tickets: "DATE_TRUNC('month', created_at)" == month)
pp store.tickets.where("DATE_TRUNC('month', created_at)" == month)
store.tickets.where("DATE_TRUNC('month', created_at)" == month)
store.tickets.where("DATE_TRUNC('month', created_at)" = month)
store.tickets.where("DATE_TRUNC('month', created_at)" == month)
@tickets = store.tickets.where("DATE_TRUNC('month', created_at)" == month)
store.tickets.where("date_trunc('month', created_at), date_trunc('year', created_at)", [month, year])
store.tickets.where("date_trunc('month', created_at), date_trunc('year', created_at)" = [month, year])
store.tickets.where("date_trunc('month', created_at), date_trunc('year', created_at)" = month, year)
pp @tickets
@tickets = store.tickets.where("DATE_TRUNC('month', created_at.to_date), DATE_TRUNC('year', created_at.to_date)" == month, year)
pp @tickets
@tickets = store.tickets.where("DATE_TRUNC('month', created_at)" == month)
pp @tickets
@tickets = store.tickets.where("DATE_TRUNC('month', created_at), DATE_TRUNC('year', created_at)" == month, year)
@tickets = store.tickets.where("DATE_TRUNC('month', created_at), DATE_TRUNC('year', created_at)" == month, year).
pp @tickets
@tickets.count
@tickets = store.tickets.where("DATE_TRUNC('month', created_at), DATE_TRUNC('year', created_at)" == month, year).where(tickets: {parent_id: nil})
store = Store.find(params[:store])
@tickets = store.tickets.where("DATE_TRUNC('month', created_at), DATE_TRUNC('year', created_at)" == month, year).where(tickets: {parent_id: nil})
store = params[:store]
year = params[:year]
month = params[:month]
params
continue
pp Order.last
Order.last
continue
@id
exit
order
continue
total
continue
6652.919 - 379.639
order.subtotal
order.total
mov.subtotal
mov.total
subtotal
total
continue
inventory
pp movement
movement
Movement.last.product_request
continue
Movement.last.product_request
Movement.last
continue
Movement.last
inventory.quantity > pending.quantity
pending.quantity
pending
inventory.quantity
continue
@collection
continue
     @collection
     @collection << movement
movement
      movement.save
     @collection = []
     @collection = Ã¾[
     @collection << movement
product.cost
product.price
product
pp movement
movement
movement = Movement.new.tap{ |movement| [movement.product = product, movement.quantity = quantity, movement.movement_type = type, movement.user = current_user, movement.unique_code = product.unique_code, movement.store = current_user.store, movement.business_unit = current_user.store.business_unit, movement.cost = product.cost, movement.total_cost = (product.cost * quantity)] }
movement = Movement.new.tap{ |movement| [movement.product = product, movement.quantity = quantity] }
        end
          movement.total_cost = (product.cost * quantity)
          movement.cost = product.cost
        unless (product.cost == 0 || product.cost == nil)
        movement.business_unit = current_user.store.business_unit
        movement.store = current_user.store
        movement.unique_code = product.unique_code
        movement.user = current_user
        movement.movement_type = type
        movement.quantity = quantity
        movement.product = product
Movement.create.tap do |movement|
@collection
continue
params
@collection
continue
@collection
continue
total
continue
total
continue
total
continue
@collection
continue
@collection
continue
exit
bill.total - @payments
bill.total - payments
bill.total -payments
bill.total <= @payments
@payments
@oayments
bill.total
bill.total <= @payments ? @pending = content_tag(:span, 'pagado', class: 'label label-success') : @pending = number_to_currency((bill.total - payments).round(2)).to_s
payments == nil ? @payments = 0 : @payments = payments
payments = payments.inject(&:+)
bill.payments.each{ |payment| payments << payment }
payments = []
payments
payments = payments.inject(&:+)
bill.total <= @payments ? @pending = content_tag(:span, 'pagado', class: 'label label-success') : @pending = number_to_currency((bill.total - payments).round(2)).to_s
@payments
(payments == nil || payments == []) ? @payments = 0 : @payments = payments
payments
bill.payments.each{ |payment| payments << payment }
payments = []
bill.payments
pp bill
exit
@ticket.children.first
@ticket.children
@ticket
continue
@payment_forms.last
@payment_forms.count
@payment_forms
continue
PaymentForm.count
continue
@pdf
continue
pdf_bill
continue
save_path
continue
status.first == ['sin asignar']
status.first
continue
status.first
status
continue
status
continue
exit
continue
File.join(@final_dir, 'factura.pdf')
pdf
exit
exut
continue
@incidents_hash
continue
xml_response
@incidents_hash
exit
pp @rows
@rows
 @incidents_hash
exit
'%.2f' % @rows.first["discount"]
@rows.first["discount"]
pp @rows.first["discount"]
pp @rows
@total_discount
@total
@rows
@incidents_hash
exit
response_hash = response.hash
xml_response
@incidents_hash
continue
@incidents_hash
continue
@sat_certificate
@incidents_hash
continue
hash = response_hash[:envelope][:body][:sign_stamp_response][:sign_stamp_result]
response_hash
xml_response
continue
@store
continue
@rows.count
@rows
continue
pp @rows
@rows.count
@rows
continue
@rows
continue
exit
params
continue
@rows.count
@rows
continue
@rows
@rows.count
continue
pp @rows
@rows.count
@rows
continue
o.pending_movements.count
o.pending_movements
o
new_hash
@rows
continue
objects.count
objects
exit
continue
exit
continue
exit
b_us.is_a?(BusinessUnit)
Prospect.find(1)
