continue
    @stamp_original_chain = stamp_xslt.apply_to(stamp_xml)
    stamp_xslt = Nokogiri::XSLT(File.read(@sat_path.join('cadenaoriginal_TFD_1_1.xslt')))
    stamp_xml = Nokogiri::XML(File.read(@working_path.join('tfd.xml')))
    extract_xml = File.open(File.join(@working_dir, 'tfd.xml'), 'w'){ |file| file.write(extract) }
    xml_url = @xml_path + 'stamped.xml'
    stamped_xml = File.open(File.join(@final_dir, 'stamped.xml'), 'w'){ |file| file.write(xml_response) }
    @cfd_last_8 = @cfd_stamp.slice((@cfd_stamp.length - 8)..@cfd_stamp.length)
    @cfd_stamp = doc.xpath('//cfdi:Complemento').children.attr('SelloCFD').value
    extract = doc.xpath('//cfdi:Complemento').children.to_xml.gsub('xsi:', '')
    doc = Nokogiri::XML(xml_response)
    @incidents_hash = hash[:incidencias]
    @sat_certificate = hash[:no_certificado_sat]
    @sat_seal = hash[:sat_seal]
    @cod_status = hash[:cod_estatus]
    @date = hash[:fecha]
    @uuid = hash[:uuid]
    xml_response = hash[:xml]
  hash = response_hash[:envelope][:body][:sign_stamp_response][:sign_stamp_result]
response_hash = response.hash
exit
response_hash = response.hash
exit
pp @rows
@rows
@ros
response_hash = response.hash
exit
response_hash = response.hash
exit
hash = response_hash[:envelope][:body][:sign_stamp_response][:sign_stamp_result]
xml_response = hash[:xml]
xml_response
exit
hash
xml_response
exit
@greatest_payment.payment_id
@greatest_payment
hash = response_hash[:envelope][:body][:sign_stamp_response][:sign_stamp_result]
response_hash = response.hash
response = client.call(:sign_stamp, message: { xml: xml_file, username: username , password: password })
request = ops.build(message: { xml: xml_file, username: username , password: password })
ops = client.operation(:sign_stamp)
continue
@store.certificate.url
@store.certificate
exit
@store.certificate_url
@store.certificate
@store
exit
continue
hash
exit
@objects
@orders
@tickets
objects
continue
exit
@total_payment
    @total_payment = total_payment.inject(&:+)
@payments.each{ |payment| total_payment << payment.second }
@payments.each{ |total_payment << payment.second| }
    total_payment = []
@payments
@paymentes
    @payments = payments.group_by(&:first).map{ |k,v| [k, v.inject(0){ |sum, i| (sum + i.second).round(2) }] }.sort_by{|pay_form| pay_form.second}.reverse
@list_of_payments
continue
@list_of_payments
@total_payment
continue
@greatest_payment
continue
@total_payment
continue
exit
@tickets.count
@tickets
exit
Prospect.find(params[:prospect])
params[:prospect]
params[:tickets]
params
continue
prospect.store
prospect
prospect = Prospect.find(params[:prospect])
Prospect.find(params[:prospect])
params[:prospect]
params
prospect.first.billing_address
prospect.first
prospect
prospect.first.billing_address
prospect.billing_address
prospect
params[:prospect]
prospect
exit
params
@store
exit
params
continue
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params
exit
params[:tickets].to_a
params[:tickets].to_h
params[:tickets]
params[:tickets][2]
params[:tickets][1]
params[:tickets][:value]
params[:tickets]
params[:tickets].value
params[:tickets][:value]
params[:tickets][:first]
params[:tickets].first
params[:tickets]
params
exit
params
exit
params[:orders] == nil
params[:orders]
exit
params[:tickets]
params
continue
exit
params
exit
params
exit
params[:tickets]
params
exit
params
exit
params
continue
@difference
continue
@difference
hello
@difference
continue
@difference
continue
@difference
@ticket_total
continue
@difference = 0
get_returns_or_changes(ticket)
continue
    end
      difference << ticket.total
    ticket.children.each do |ticket|
difference = []
    @difference
    difference == nil ? @difference = 0 : @difference == difference
    difference = difference.inject(&:+)
    end
      difference << ticket.total
    ticket.children.each do |ticket|
    difference = []
ticket.total
get_returns_or_changes(ticket)
ticket
@difference
exit
Movement.last
Movement.last.update(quantity: nil)
Movement.last
Movement.last.update(quantity: Movement.last.product_id)
Movement.last
c
c = 'hello'
Movement.last
Movement.last.update(movement_type: 'ventota')
Movement.last
self
Movement.last
Movement.last.dup.save
Movement.last.dup
m = Movement.last.dup
Movement.last.dup
def remove_attributes(attributes)
self
Movement.last
exit
self.movement_type
self.quantity
self
exit
Movement.last.movement_type
Movement.last.quantity
Movement.last
exit
@product_request.movements
continue
@product_request.movements
@product_request
continue
@orders.each{ |order| order.update(confirm: true)}
@orders = Order.find(params[:ids].split('/'))
Order.find(params[:ids].split('/'))
continue
exit
self
self.update(quantity: total_quantity, entry_movement: mov, total_cost: self.cost * total_quantity, discount_applied: (self.discount_applied * total_quantity).round(2), automatic_discount: (self.automatic_discount * total_quantity).round(2), taxes: (self.taxes * total_quantity).round(2), subtotal: (self.subtotal * total_quantity).round(2), total: (self.subtotal * total_quantity).round(2) - (self.discount_applied * total_quantity).round(2) + (self.taxes * total_quantity).round(2))
self.update(quantity: total_quantity, entry_movement: mov, total_cost: self.cost * total_quantity, discount_applied: (self.discount_applied * total_quantity).round(2), automatic_discount: (self.automatic_discount * total_quantity).round(2), taxes: (self.taxes * total_quantity).round(2), subtotal: (self.subtotal * total_quantity).round(2), total: (self.subtotal * total_quantity).round(2) - (self.discount * total_quantity).round(2) + (self.taxes * total_quantity).round(2))
self.update(quantity: total_quantity, entry_movement: mov, total_cost: self.cost * total_quantity, discount_applied: (self.discount * total_quantity).round(2), automatic_discount: (self.discount * total_quantity).round(2), taxes: (self.taxes * total_quantity).round(2), subtotal: (self.subtotal * total_quantity).round(2), total: (self.subtotal * total_quantity).round(2) - (self.discount * total_quantity).round(2) + (self.taxes * total_quantity).round(2))
                    )
                    total: (self.subtotal * total_quantity).round(2) - (self.discount * total_quantity).round(2) + (self.taxes * total_quantity).round(2)
                    subtotal: (self.subtotal * total_quantity).round(2),
                    taxes: (self.taxes * total_quantity).round(2),
                    automatic_discount: (self.discount * total_quantity).round(2),
                    discount_applied: (self.discount * total_quantity).round(2),
                    total_cost: self.cost * total_quantity,
                    entry_movement: mov,
                    quantity: total_quantity,
        self.update(
self.update
total_quantity
self
mov_sales.include?(Movement.last)
mov_sales << Movement.last unless mov_sales.include?(Movement.last)
mov_sales.include?(Movement.last)
mov_sales = entry.movement.sales
mov = entry.movement
total_quantity >= entry.fix_quantity
entry.fix_quantity
entry = related_warehouses(order_type).first
total_quantity
related_warehouses(order_type).first
related_warehouses(order_type)
exit
(self.subtotal * entry.fix_quantity).round(2)
self.subtotal * entry.fix_quantity
