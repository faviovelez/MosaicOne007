continue
exit
reg
cad
reg.class.where(cad)
reg.class.where(cad).first
reg
object
object.id
continue
exit
continue
exit
continue
id = vinculate_relations(attr.first, attr.last)
new_reg
new
attr.first
is_relation_object(attr.first)
exit
continue
values[:object]
exit
continue
klass
continue
klass
continue
value = values[:object].first.second
reference = values[:object].first.first
/_id/.match(attribute).present?
attribute != 'store_id'
attribute = values[:object].first.first
is_relation_object(values[:object].first.first)
is_relation_object(attribute)(values[:object].first.first)
values[:object].first.first
values[:object].first
values[:object]
values
new_reg
klass
continue
exit
pp params["users"].each{ |key, values| puts key["object"]}
pp params["users"].each{ |key, values| puts key[:object]}
hello[:object]
hello
hello = params["users"].each{ |key, values| values}
pp params["users"].each{ |key, values| puts values}
pp params["users"].each{ |key, values| puts key}
pp params["users"].each{ |key, values| puts values}
params["users"].each{ |key, values| puts values}
"users".singularize.camelize.constantize
params["users"].each{ |key, values| puts key}
params["users"].each{ |key, values| puts values}
params["users"].each{ |key, values| puts value}
params["users"].each{ |key, values| puts key}
params["users"].each{ |key, values| puts key, puts value}
params["users"].each{ |key, values| [puts key, puts value]}
params["users"]
@ids_references["user"]
@ids_references["users".singularize]
@ids_references["users".singularize] = {}
@ids_references["users".singularize]
@ids_references = {}
@ids_references
@ids_references["users".singularize]
"users".singularize
table_name.singularize
tables_orders.each{ |table| puts table }
tables_orders
code == Store.find(params[:storeId]).install_code
Store.find(params[:storeId]).install_code
Store.find(params[:storeId]).install_code)
code
code = BCrypt::Password.new(params[:installCode])
BCrypt::Password.new(params[:installCode])
params[:po]
params[:installCode]
pp params[:installCode]
pp params[:storeId].install_code
pp params[:storeId][:install_code]
pp params[:storeId]
pp params[:po][:users]
pp params[:users]
pp params[:installCode]
pp params["install_code"]
pp params[:install_code]
pp params[:po]
pp params
params
parameters
exit
store_with_install_code.id
store_with_install_code = Store.where(install_code: self.install_code).first
my_store_id = self.id
Store.where(install_code: self.install_code).first
Store.where(install_code: self.install_code).first.present?
continue
response_hash[:envelope][:body][:cancel_response][:cancel_result][:cod_estatus]
response_hash[:envelope][:body][:cancel_response][:cancel_result]
response_hash[:envelope][:body][:cancel_response][:cancel_result][:cod_estatus]
continue
receipt
exit
response_hash[:envelope][:body][:cancel_response][:cancel_result][:cod_estatus]
response_hash[:envelope][:body][:cancel_response][:cancel_result]
response_hash[:envelope][:body][:cancel_response]
response_hash[:envelope][:body]
response_hash[:envelope[:body]
response_hash[:envelope]
response_hash
receipt
continue
exit
bill
pp bill.tickets.first.payments.first.bill
bill.payments
bill.payment
bill.payments
bill
pp bill.tickets.first.payments.first.bill
pp bill.tickets.first.payments.first
pp bill.tickets.first.payments
pp bill.tickets.first
pp bill.tickets
pp bill.payments
bill
payments
@payments
bill.total.round(2)
bill.total
continue
exit
row.subtotal
(row.subtotal / row.quantity * quantities_filtered[n].to_i).round(2)
row.total
(row.total / row.quantity * quantities_filtered[n].to_i).round(2)
row.quantity
row = @bill.rows.select{|row| row.product == id}.first
id = product.id
product = Product.find(products_filtered[n])
quantities_filtered
quantities_filtered.count
          products_filtered = products_unfiltered.delete_if.with_index{ |e,i| zeroes.include?(i) }
          quantities_filtered = quantities_unfiltered.delete_if.with_index{ |e,i| zeroes.include?(i) }
          zeroes = quantities_unfiltered.each_index.select{|i| quantities_unfiltered[i] == '0'}
          products_unfiltered = params[:products]
          quantities_unfiltered = params[:quantities]
n = 0
@relation_type == '03'
exit
@rows
exit
@relation_type == '01'
@relation_type != nil
(params[:relation_type] != nil && params[:relation_type] != '')
params[:relation_type] != ''
params[:relation_type] != nil
(params[:relation_type] != nil || params[:relation_type] != '')
continue
params[:relation_type]
exit
params[:relation_type]
continue
exit
@store
Prospect.where(legal_or_business_name:'Público en General', direct_phone: 1111111111, prospect_type: 'público en general', contact_first_name: 'ninguno', contact_last_name: 'ninguno', store: St)
prospects.each do |prospect|
prospect.each do |prospect|
prospects = Prospect.where(legal_or_business_name:'Público en General', direct_phone: 1111111111, prospect_type: 'público en general', contact_first_name: 'ninguno', contact_last_name: 'ninguno')
Prospect.where(legal_or_business_name:'Público en General', direct_phone: 1111111111, prospect_type: 'público en general', contact_first_name: 'ninguno', contact_last_name: 'ninguno')
Prospect.where(legal_or_business_name:'Público en General', direct_phone: 1111111111, prospect_type: 'público en general', contact_first_name: 'ninguno', contact_last_name: 'ninguno').each do |prospect|
Prospect.where(legal_or_business_name:'Público en General', direct_phone: 1111111111, prospect_type: 'público en general', contact_first_name: 'ninguno', contact_last_name: 'ninguno').count
Prospect.where(legal_or_business_name:'Público en General', direct_phone: 1111111111, prospect_type: 'público en general', contact_first_name: 'ninguno', contact_last_name: 'ninguno')
Prospect.where(legal_or_business_name:'Público en General', direct_phone: 1111111111, prospect_type: 'público en general', contact_first_name: 'ninguno', contact_last_name: 'ninguno', store: @store)
(params[:cfdi_type] == 'global' || @cfdi_type == 'global')
@cfdi_type == 'global'
params[:cfdi_type] == 'global'
continue
exit
continue
exit
incidents = File.open(File.join(@working_dir, 'incidencias.txt'), 'w'){ |file| file.write(@incidents_hash) }
@incidents_hash[:incidencia][:mensaje_incidencia]
@incidents_hash[:mensaje_incidencia]
@incidents_hash
continue
exit
@cod_status = hash[:cod_estatus]
@incidents_hash = hash[:incidencias]
hash = response_hash[:envelope][:body][:stamp_response][:stamp_result]
response_hash
response_hash = response.hash
hash
request.to_s
request.to_hash
request.to_h
request.hash
response_hash
request
response
converted_response = response.force_encoding('UTF-8')
soap_response = File.open(File.join(@working_dir, 'response.xml'), 'w'){ |file| file.write(response) }
response
xml_response
exit
ENV['stamp_dir']
@s_billing
response_hash
exit
response_hash = response.hash
response = client.call(:stamp, message: { xml: xml_file, username: username , password: password })
request = ops.build(message: { xml: xml_file, username: username , password: password })
ops = client.operation(:stamp)
xml_file = Base64.encode64(file.delete("\n"))
file
response_hash = response.hash
response = client.call(:stamp, message: { xml: xml_new_clean, username: username , password: password })
request = ops.build(message: { xml: xml_new_clean, username: username , password: password })
response_hash = response.hash
response = client.call(:stamp, message: { xml: xml_new_file, username: username , password: password })
request = ops.build(message: { xml: xml_new_file, username: username , password: password })
response_hash = response.hash
response = client.call(:stamp, message: { xml: xml_clean, username: username , password: password })
request = ops.build(message: { xml: xml_clean, username: username , password: password })
ops = client.operation(:stamp) 
    response_hash = response.hash
    response = client.call(:stamp, message: { xml: xml_file, username: username , password: password })
    request = ops.build(message: { xml: xml_file, username: username , password: password })
    ops = client.operation(:stamp) ##CAMBIAR A STAMP CUANDO SEAN EXITOSAS LAS PRUEBAS
    password = ENV['password_pac']
    username = ENV['username_pac']
xml_new_clean = xml_new_file.delete("\n")
xml_new_file = Base64.encode64(new_file)
new_file = file.delete("\n")
file
hello = Base64.encode64('      ')
hello = Base64.encode64('     ')
hello = Base64.encode64('    ')
hello = Base64.encode64('   ')
hello = Base64.encode64('  ')
hello = Base64.encode64(' ')
hello = Base64.encode64('')
hello = Base64.encode64('  ')
hello = Base64.encode64(' ')
xml_file = Base64.encode64(file)
file = File.read(@working_path.join('unstamped.xml'))
xml_new_clean_2
xml_clean
xml_new_clean_2
xml_new_clean_2 == xml_clean
xml_new_clean_2
xml_new_clean_2 = xml_new_clean.delete("=")
xml_new_clean
xml_new_clean == xml_clean
